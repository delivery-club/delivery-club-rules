// Code generated by "precompile.go". DO NOT EDIT.

package rulesdata

import "github.com/quasilyte/go-ruleguard/ruleguard/ir"

var PrecompiledRules = &ir.File{
	PkgPath:       "gorules",
	CustomDecls:   []string{},
	BundleImports: []ir.BundleImport{},
	RuleGroups: []ir.RuleGroup{
		{
			Line:        15,
			Name:        "unusedFormatting",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects unused formatting functionality",
			DocBefore:   "fmt.Sprintf(\"42\")",
			DocAfter:    "fmt.Sprint(\"42\")",
			Imports: []ir.PackageImport{{
				Path: "github.com/pkg/errors",
				Name: "errors",
			}},
			Rules: []ir.Rule{{
				Line: 18,
				SyntaxPatterns: []ir.PatternString{
					{Line: 18, Value: "fmt.Sprintf($_)"},
					{Line: 18, Value: "errors.WithMessagef($_, $_)"},
					{Line: 18, Value: "errors.Wrapf($_, $_)"},
					{Line: 18, Value: "errors.Errorf($_)"},
				},
				ReportTemplate: "use function alternative without formatting",
			}},
		},
		{
			Line:        26,
			Name:        "uncheckedTypeAssert",
			MatcherName: "m",
			DocTags:     []string{"diagnostic"},
			DocSummary:  "Detects unchecked type assertation",
			DocBefore:   "foo := bar.(string) // var bar interface{}",
			DocAfter:    "foo, ok := bar.(string)",
			Rules: []ir.Rule{{
				Line: 27,
				SyntaxPatterns: []ir.PatternString{
					{Line: 28, Value: "$_ := $_.($_)"},
					{Line: 29, Value: "$_ = $_.($_)"},
					{Line: 30, Value: "$_($*_, $_.($_), $*_)"},
					{Line: 31, Value: "$_{$*_, $_.($_), $*_}"},
					{Line: 32, Value: "$_{$*_, $_: $_.($_), $*_}"},
					{Line: 33, Value: "$_ <- $_.($_)"},
					{Line: 34, Value: "$_{$*_, $_.($_): $_, $*_}"},
				},
				ReportTemplate: "avoid unchecked type assertions as they can panic",
			}},
		},
		{
			Line:        42,
			Name:        "rangeCopyVal",
			MatcherName: "m",
			DocTags:     []string{"performance"},
			DocSummary:  "Detects copy big structs in loop body",
			DocBefore:   "for _, x := range xs { myfunc(x) } // for example var xs [][2048]string",
			DocAfter:    "for i := range xs { myfunc(xs[i]) }",
			Rules: []ir.Rule{{
				Line: 43,
				SyntaxPatterns: []ir.PatternString{
					{Line: 43, Value: "for $_, $x := range $xs { $*_ }"},
					{Line: 43, Value: "for $_, $x = range $xs { $*_ }"},
				},
				ReportTemplate: "each iteration copies more than 256 bytes (consider pointers or indexing)",
				WhereExpr: ir.FilterExpr{
					Line: 44,
					Op:   ir.FilterAndOp,
					Src:  "(m[\"xs\"].Type.Is(\"[]$_\") || m[\"xs\"].Type.Is(\"[$_]$_\")) && m[\"x\"].Type.Size >= 256",
					Args: []ir.FilterExpr{
						{
							Line: 44,
							Op:   ir.FilterOrOp,
							Src:  "(m[\"xs\"].Type.Is(\"[]$_\") || m[\"xs\"].Type.Is(\"[$_]$_\"))",
							Args: []ir.FilterExpr{
								{
									Line:  44,
									Op:    ir.FilterVarTypeIsOp,
									Src:   "m[\"xs\"].Type.Is(\"[]$_\")",
									Value: "xs",
									Args:  []ir.FilterExpr{{Line: 44, Op: ir.FilterStringOp, Src: "\"[]$_\"", Value: "[]$_"}},
								},
								{
									Line:  44,
									Op:    ir.FilterVarTypeIsOp,
									Src:   "m[\"xs\"].Type.Is(\"[$_]$_\")",
									Value: "xs",
									Args:  []ir.FilterExpr{{Line: 44, Op: ir.FilterStringOp, Src: "\"[$_]$_\"", Value: "[$_]$_"}},
								},
							},
						},
						{
							Line: 44,
							Op:   ir.FilterGtEqOp,
							Src:  "m[\"x\"].Type.Size >= 256",
							Args: []ir.FilterExpr{
								{
									Line:  44,
									Op:    ir.FilterVarTypeSizeOp,
									Src:   "m[\"x\"].Type.Size",
									Value: "x",
								},
								{
									Line:  44,
									Op:    ir.FilterIntOp,
									Src:   "256",
									Value: int64(256),
								},
							},
						},
					},
				},
				LocationVar: "x",
			}},
		},
		{
			Line:        53,
			Name:        "rangeExprCopy",
			MatcherName: "m",
			DocTags:     []string{"performance"},
			DocSummary:  "Detects big array copy in loop",
			DocBefore:   "for _, x := range xs { myfunc(x) } // var xs [2048]string",
			DocAfter:    "for _, x := range &xs { myfunc(x) }",
			Rules: []ir.Rule{{
				Line: 54,
				SyntaxPatterns: []ir.PatternString{
					{Line: 54, Value: "for $_, $_ := range $x { $*_ }"},
					{Line: 55, Value: "for $_, $_ = range $x { $*_ }"},
				},
				ReportTemplate:  "copy of $x can be avoided with &$x",
				SuggestTemplate: "&$x",
				WhereExpr: ir.FilterExpr{
					Line: 56,
					Op:   ir.FilterAndOp,
					Src:  "m[\"x\"].Type.Is(\"[$_]$_\") && m[\"x\"].Type.Size >= 256",
					Args: []ir.FilterExpr{
						{
							Line:  56,
							Op:    ir.FilterVarTypeIsOp,
							Src:   "m[\"x\"].Type.Is(\"[$_]$_\")",
							Value: "x",
							Args:  []ir.FilterExpr{{Line: 56, Op: ir.FilterStringOp, Src: "\"[$_]$_\"", Value: "[$_]$_"}},
						},
						{
							Line: 56,
							Op:   ir.FilterGtEqOp,
							Src:  "m[\"x\"].Type.Size >= 256",
							Args: []ir.FilterExpr{
								{
									Line:  56,
									Op:    ir.FilterVarTypeSizeOp,
									Src:   "m[\"x\"].Type.Size",
									Value: "x",
								},
								{
									Line:  56,
									Op:    ir.FilterIntOp,
									Src:   "256",
									Value: int64(256),
								},
							},
						},
					},
				},
				LocationVar: "x",
			}},
		},
		{
			Line:        64,
			Name:        "ifacePtr",
			MatcherName: "m",
			DocTags:     []string{"performance"},
			DocSummary:  "Detects pointer to interface{}",
			Rules: []ir.Rule{{
				Line:           65,
				SyntaxPatterns: []ir.PatternString{{Line: 65, Value: "*$x"}},
				ReportTemplate: "don't use pointers to an interface",
				WhereExpr: ir.FilterExpr{
					Line:  66,
					Op:    ir.FilterVarTypeUnderlyingIsOp,
					Src:   "m[\"x\"].Type.Underlying().Is(`interface{ $*_ }`)",
					Value: "x",
					Args:  []ir.FilterExpr{{Line: 66, Op: ir.FilterStringOp, Src: "`interface{ $*_ }`", Value: "interface{ $*_ }"}},
				},
			}},
		},
		{
			Line:        74,
			Name:        "camelCaseNaming",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects non camel case naming strategy for functions, constants, types, variables",
			DocBefore:   "type my_type struct {}",
			DocAfter:    "type myType struct {}",
			Rules: []ir.Rule{{
				Line: 75,
				SyntaxPatterns: []ir.PatternString{
					{Line: 76, Value: "func $x($*_) $*_ { $*_ }"},
					{Line: 77, Value: "func ($_) $x($*_) $*_ { $*_ }"},
					{Line: 78, Value: "func ($_ $_) $x($*_) $*_ { $*_ }"},
					{Line: 79, Value: "const $x = $_"},
					{Line: 79, Value: "const $x $_ = $_"},
					{Line: 80, Value: "const ($x = $_; $*_)"},
					{Line: 81, Value: "const ($_ = $_; $x = $_; $*_)"},
					{Line: 82, Value: "const ($x $_= $_; $*_)"},
					{Line: 83, Value: "const ($_ $_ = $_; $x $_= $_; $*_)"},
					{Line: 84, Value: "type $x $_"},
					{Line: 85, Value: "$x := $_"},
					{Line: 86, Value: "var $x = $_"},
					{Line: 87, Value: "var $x $_ = $_"},
				},
				ReportTemplate: "use camelCase naming strategy",
				WhereExpr: ir.FilterExpr{
					Line: 89,
					Op:   ir.FilterAndOp,
					Src:  "!m[\"x\"].Text.Matches(`^_$`) && (m[\"x\"].Text.Matches(`-`) || m[\"x\"].Text.Matches(`_`))",
					Args: []ir.FilterExpr{
						{
							Line: 89,
							Op:   ir.FilterNotOp,
							Src:  "!m[\"x\"].Text.Matches(`^_$`)",
							Args: []ir.FilterExpr{{
								Line:  89,
								Op:    ir.FilterVarTextMatchesOp,
								Src:   "m[\"x\"].Text.Matches(`^_$`)",
								Value: "x",
								Args:  []ir.FilterExpr{{Line: 89, Op: ir.FilterStringOp, Src: "`^_$`", Value: "^_$"}},
							}},
						},
						{
							Line: 89,
							Op:   ir.FilterOrOp,
							Src:  "(m[\"x\"].Text.Matches(`-`) || m[\"x\"].Text.Matches(`_`))",
							Args: []ir.FilterExpr{
								{
									Line:  89,
									Op:    ir.FilterVarTextMatchesOp,
									Src:   "m[\"x\"].Text.Matches(`-`)",
									Value: "x",
									Args:  []ir.FilterExpr{{Line: 89, Op: ir.FilterStringOp, Src: "`-`", Value: "-"}},
								},
								{
									Line:  89,
									Op:    ir.FilterVarTextMatchesOp,
									Src:   "m[\"x\"].Text.Matches(`_`)",
									Value: "x",
									Args:  []ir.FilterExpr{{Line: 89, Op: ir.FilterStringOp, Src: "`_`", Value: "_"}},
								},
							},
						},
					},
				},
				LocationVar: "x",
			}},
		},
		{
			Line:        98,
			Name:        "notInformativePackageNaming",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects general names for package",
			DocBefore:   "package lib",
			DocAfter:    "package concreteLib",
			Rules: []ir.Rule{{
				Line:           99,
				SyntaxPatterns: []ir.PatternString{{Line: 99, Value: "package $x"}},
				ReportTemplate: "don't use general names to package naming",
				WhereExpr: ir.FilterExpr{
					Line: 100,
					Op:   ir.FilterOrOp,
					Src:  "m[\"x\"].Text.Matches(`(^c|C|_(c|C))ommon([A-Z]|_|$|\\d)`) ||\n\tm[\"x\"].Text.Matches(`(^l|L|_(l|L))ib([A-Z]|_|$|\\d)`) ||\n\tm[\"x\"].Text.Matches(`(^u|U|_(u|U))til([A-Z]|_|$|\\d)`) ||\n\tm[\"x\"].Text.Matches(`(^s|S|_(s|S))hared([A-Z]|_|$|\\d)`)",
					Args: []ir.FilterExpr{
						{
							Line: 100,
							Op:   ir.FilterOrOp,
							Src:  "m[\"x\"].Text.Matches(`(^c|C|_(c|C))ommon([A-Z]|_|$|\\d)`) ||\n\tm[\"x\"].Text.Matches(`(^l|L|_(l|L))ib([A-Z]|_|$|\\d)`) ||\n\tm[\"x\"].Text.Matches(`(^u|U|_(u|U))til([A-Z]|_|$|\\d)`)",
							Args: []ir.FilterExpr{
								{
									Line: 100,
									Op:   ir.FilterOrOp,
									Src:  "m[\"x\"].Text.Matches(`(^c|C|_(c|C))ommon([A-Z]|_|$|\\d)`) ||\n\tm[\"x\"].Text.Matches(`(^l|L|_(l|L))ib([A-Z]|_|$|\\d)`)",
									Args: []ir.FilterExpr{
										{
											Line:  100,
											Op:    ir.FilterVarTextMatchesOp,
											Src:   "m[\"x\"].Text.Matches(`(^c|C|_(c|C))ommon([A-Z]|_|$|\\d)`)",
											Value: "x",
											Args:  []ir.FilterExpr{{Line: 100, Op: ir.FilterStringOp, Src: "`(^c|C|_(c|C))ommon([A-Z]|_|$|\\d)`", Value: "(^c|C|_(c|C))ommon([A-Z]|_|$|\\d)"}},
										},
										{
											Line:  101,
											Op:    ir.FilterVarTextMatchesOp,
											Src:   "m[\"x\"].Text.Matches(`(^l|L|_(l|L))ib([A-Z]|_|$|\\d)`)",
											Value: "x",
											Args:  []ir.FilterExpr{{Line: 101, Op: ir.FilterStringOp, Src: "`(^l|L|_(l|L))ib([A-Z]|_|$|\\d)`", Value: "(^l|L|_(l|L))ib([A-Z]|_|$|\\d)"}},
										},
									},
								},
								{
									Line:  102,
									Op:    ir.FilterVarTextMatchesOp,
									Src:   "m[\"x\"].Text.Matches(`(^u|U|_(u|U))til([A-Z]|_|$|\\d)`)",
									Value: "x",
									Args:  []ir.FilterExpr{{Line: 102, Op: ir.FilterStringOp, Src: "`(^u|U|_(u|U))til([A-Z]|_|$|\\d)`", Value: "(^u|U|_(u|U))til([A-Z]|_|$|\\d)"}},
								},
							},
						},
						{
							Line:  103,
							Op:    ir.FilterVarTextMatchesOp,
							Src:   "m[\"x\"].Text.Matches(`(^s|S|_(s|S))hared([A-Z]|_|$|\\d)`)",
							Value: "x",
							Args:  []ir.FilterExpr{{Line: 103, Op: ir.FilterStringOp, Src: "`(^s|S|_(s|S))hared([A-Z]|_|$|\\d)`", Value: "(^s|S|_(s|S))hared([A-Z]|_|$|\\d)"}},
						},
					},
				},
				LocationVar: "x",
			}},
		},
		{
			Line:        112,
			Name:        "getterNaming",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects 'get' word in getter functions",
			DocBefore:   "func (x myType) getValue() string { return x.v }",
			DocAfter:    "func (x myType) value() string { return x.v }",
			Rules: []ir.Rule{{
				Line: 113,
				SyntaxPatterns: []ir.PatternString{
					{Line: 114, Value: "func ($x $_) $name($*_) $*_ { return $x.$_ }"},
					{Line: 115, Value: "func ($x $_) $name($*_) $*_ { return $_($x.$_) }"},
					{Line: 116, Value: "func ($x $_) $name($*_) $*_ { return $_($x) }"},
					{Line: 117, Value: "func ($x $_) $name($*_) $*_ { return $_(*$x) }"},
				},
				ReportTemplate: "don't use 'get' in getter functions",
				WhereExpr: ir.FilterExpr{
					Line:  119,
					Op:    ir.FilterVarTextMatchesOp,
					Src:   "m[\"name\"].Text.Matches(`(^g|G|_(g|G))et([A-Z]|$|_|\\d)`)",
					Value: "name",
					Args:  []ir.FilterExpr{{Line: 119, Op: ir.FilterStringOp, Src: "`(^g|G|_(g|G))et([A-Z]|$|_|\\d)`", Value: "(^g|G|_(g|G))et([A-Z]|$|_|\\d)"}},
				},
				LocationVar: "name",
			}},
		},
		{
			Line:        136,
			Name:        "interfaceWordInInterfaceDeclaration",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects 'interface' word in interface declarations",
			DocBefore:   "type interfaceDb interface { }",
			DocAfter:    "type db interface { }",
			Rules: []ir.Rule{{
				Line:           137,
				SyntaxPatterns: []ir.PatternString{{Line: 137, Value: "type $name interface{ $*_ }"}},
				ReportTemplate: "don't use 'interface' word' in interface declaration'",
				WhereExpr: ir.FilterExpr{
					Line:  138,
					Op:    ir.FilterVarTextMatchesOp,
					Src:   "m[\"name\"].Text.Matches(`(^i|I|_(i|I))nterface([A-Z]|_|$|\\d)`)",
					Value: "name",
					Args:  []ir.FilterExpr{{Line: 138, Op: ir.FilterStringOp, Src: "`(^i|I|_(i|I))nterface([A-Z]|_|$|\\d)`", Value: "(^i|I|_(i|I))nterface([A-Z]|_|$|\\d)"}},
				},
				LocationVar: "name",
			}},
		},
		{
			Line:        148,
			Name:        "simplifyErrorReturn",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects expressions that can be rewritten in form without 'if' usage",
			DocBefore:   "err := myFunc(); if err != nil { return err }; return nil",
			DocAfter:    "return myFunc()",
			Rules: []ir.Rule{{
				Line: 149,
				SyntaxPatterns: []ir.PatternString{
					{Line: 149, Value: "if $*_, $err = $f($*args); $err != nil { return $err }; return nil"},
					{Line: 150, Value: "if $*_, $err := $f($*args); $err != nil { return $err }; return nil"},
					{Line: 151, Value: "$*_, $err = $f($*args); if $err != nil { return $err }; return nil"},
					{Line: 152, Value: "var $*_, $err = $f($*args); if $err != nil { return $err }; return nil"},
					{Line: 153, Value: "$*_, $err := $f($*args); if $err != nil { return $err }; return nil"},
					{Line: 154, Value: "if $*_, $err = $f($*args); $err != nil { return $err }; return $err"},
					{Line: 155, Value: "if $*_, $err := $f($*args); $err != nil { return $err }; return $err"},
					{Line: 156, Value: "$*_, $err = $f($*args); if $err != nil { return $err }; return $err"},
					{Line: 157, Value: "var $*_, $err = $f($*args); if $err != nil { return $err }; return $err"},
					{Line: 158, Value: "$*_, $err := $f($*args); if $err != nil { return $err }; return $err"},
				},
				ReportTemplate: "may be simplified to return error without if statement",
				WhereExpr: ir.FilterExpr{
					Line:  160,
					Op:    ir.FilterVarTypeImplementsOp,
					Src:   "m[\"err\"].Type.Implements(\"error\")",
					Value: "err",
					Args:  []ir.FilterExpr{{Line: 160, Op: ir.FilterStringOp, Src: "\"error\"", Value: "error"}},
				},
			}},
		},
		{
			Line:        168,
			Name:        "simplifyErrorReturnWithErrorsPkg",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects expressions that can be rewritten in form without 'if' usage",
			DocBefore:   "err := myFunc(); if err != nil { return errors.WithMessage(err, \"on myFunc:\") }; return nil",
			DocAfter:    "return errors.WithMessage(myFunc(), \"on myFunc:\")",
			Imports: []ir.PackageImport{{
				Path: "github.com/pkg/errors",
				Name: "errors",
			}},
			Rules: []ir.Rule{{
				Line: 171,
				SyntaxPatterns: []ir.PatternString{
					{Line: 172, Value: "if $*_, $err = $f($*args); $err != nil { return errors.$_($err, $*methodArgs) }; return nil"},
					{Line: 173, Value: "if $*_, $err := $f($*args); $err != nil { return errors.$_($err, $*methodArgs) }; return nil"},
					{Line: 174, Value: "$*_, $err = $f($*args); if $err != nil { return errors.$_($err, $*methodArgs) }; return nil"},
					{Line: 175, Value: "var $*_, $err = $f($*args); if $err != nil { return errors.$_($err, $*methodArgs) }; return nil"},
					{Line: 176, Value: "$*_, $err := $f($*args); if $err != nil { return errors.$_($err, $*methodArgs) }; return nil"},
					{Line: 177, Value: "if $*_, $err = $f($*args); $err != nil { return errors.$_($err, $*methodArgs) }; return $err"},
					{Line: 178, Value: "if $*_, $err := $f($*args); $err != nil { return errors.$_($err, $*methodArgs) }; return $err"},
					{Line: 179, Value: "$*_, $err = $f($*args); if $err != nil { return errors.$_($err, $*methodArgs) }; return $err"},
					{Line: 180, Value: "var $*_, $err = $f($*args); if $err != nil { return errors.$_($err, $*methodArgs) }; return $err"},
					{Line: 181, Value: "$*_, $err := $f($*args); if $err != nil { return errors.$_($err, $*methodArgs) }; return $err"},
				},
				ReportTemplate: "may be simplified to return error without if statement",
				WhereExpr: ir.FilterExpr{
					Line:  183,
					Op:    ir.FilterVarTypeImplementsOp,
					Src:   "m[\"err\"].Type.Implements(\"error\")",
					Value: "err",
					Args:  []ir.FilterExpr{{Line: 183, Op: ir.FilterStringOp, Src: "\"error\"", Value: "error"}},
				},
			}},
		},
		{
			Line:        217,
			Name:        "deferInLoop",
			MatcherName: "m",
			DocTags:     []string{"diagnostic"},
			DocSummary:  "Detects loops inside functions that use defer",
			DocBefore:   "for _, filename := range []string{\"foo\", \"bar\"} { f, err := os.Open(filename); defer f.Close() }",
			DocAfter:    "func process(filename string) {",
			Rules: []ir.Rule{{
				Line: 218,
				SyntaxPatterns: []ir.PatternString{
					{Line: 219, Value: "for $*_; $*_; $*_ { $*_; defer func($*args) $*_ { $*_ }($*_); $*_ }"},
					{Line: 220, Value: "for $*_; $*_; $*_ { $*_; defer $_($*args); $*_ }"},
					{Line: 222, Value: "for { $*_; defer func($*args) $*_ { $*_ }($*_); $*_ }"},
					{Line: 223, Value: "for { $*_; defer $_($*args); $*_ }"},
					{Line: 225, Value: "for $_, $_ := range $_ { $*_; defer func($*args) $*_ { $*_ }($*_); $*_ }"},
					{Line: 226, Value: "for $_, $_ := range $_ { $*_; defer $_($*args); $*_ }"},
					{Line: 228, Value: "for $_, $_ = range $_ { $*_; defer func($*args) $*_ { $*_ }($*_); $*_ }"},
					{Line: 229, Value: "for $_, $_ = range $_ { $*_; defer $_($*args); $*_ }"},
					{Line: 231, Value: "for $_ := range $_ { $*_; defer func($*args) $*_ { $*_ }($*_); $*_ }"},
					{Line: 232, Value: "for $_ := range $_ { $*_; defer $_($*args); $*_ }"},
					{Line: 234, Value: "for $_ = range $_ { $*_; defer func($*args) $*_ { $*_ }($*_); $*_ }"},
					{Line: 235, Value: "for $_ = range $_ { $*_; defer $_($*args); $*_ }"},
					{Line: 237, Value: "for range $_ { $*_; defer func($*args) $*_ { $*_ }($*_); $*_ }"},
					{Line: 238, Value: "for range $_ { $*_; defer $_($*args); $*_ }"},
				},
				ReportTemplate: "Possible resource leak, 'defer' is called in the 'for' loop",
				LocationVar:    "args",
			}},
		},
		{
			Line:        248,
			Name:        "queryWithoutContext",
			MatcherName: "m",
			DocTags:     []string{"diagnostic"},
			DocSummary:  "Detects queries to database without context",
			DocBefore:   "db.Exec(`SELECT 1`)",
			DocAfter:    "db.ExecContext(ctx, `SELECT 1`)",
			Imports: []ir.PackageImport{{
				Path: "github.com/delivery-club/delivery-club-rules/pkg",
				Name: "pkg",
			}},
			Rules: []ir.Rule{{
				Line: 255,
				SyntaxPatterns: []ir.PatternString{
					{Line: 256, Value: "$db.Query($*_)"},
					{Line: 257, Value: "$db.Queryx($*_)"},
					{Line: 258, Value: "$db.QueryRow($*_)"},
					{Line: 259, Value: "$db.QueryRowx($*_)"},
					{Line: 260, Value: "$db.NamedQuery($*_)"},
					{Line: 262, Value: "$db.Exec($*_)"},
					{Line: 263, Value: "$db.MustExec($*_)"},
					{Line: 264, Value: "$db.NamedExec($*_)"},
					{Line: 266, Value: "$db.Get($*_)"},
					{Line: 267, Value: "$db.Select($*_)"},
					{Line: 269, Value: "$db.Prepare($*_)"},
					{Line: 270, Value: "$db.Preparex($*_)"},
					{Line: 271, Value: "$db.PrepareNamed($*_)"},
					{Line: 273, Value: "$db.Ping($*_)"},
					{Line: 274, Value: "$db.Begin($*_)"},
					{Line: 275, Value: "$db.MustBegin($*_)"},
					{Line: 277, Value: "$db.Stmt($*_)"},
					{Line: 278, Value: "$db.Stmtx($*_)"},
					{Line: 279, Value: "$db.NamedStmt($*_)"},
				},
				ReportTemplate: "don't send query to external storage without context",
				WhereExpr: ir.FilterExpr{
					Line: 281,
					Op:   ir.FilterAndOp,
					Src:  "m[\"db\"].Object.Is(\"Var\") &&\n\t(m[\"db\"].Type.Implements(`pkg.SQLDb`) || m[\"db\"].Type.Implements(`pkg.SQLStmt`) || m[\"db\"].Type.Implements(`pkg.SQLTx`))",
					Args: []ir.FilterExpr{
						{
							Line:  281,
							Op:    ir.FilterVarObjectIsOp,
							Src:   "m[\"db\"].Object.Is(\"Var\")",
							Value: "db",
							Args:  []ir.FilterExpr{{Line: 281, Op: ir.FilterStringOp, Src: "\"Var\"", Value: "Var"}},
						},
						{
							Line: 282,
							Op:   ir.FilterOrOp,
							Src:  "(m[\"db\"].Type.Implements(`pkg.SQLDb`) || m[\"db\"].Type.Implements(`pkg.SQLStmt`) || m[\"db\"].Type.Implements(`pkg.SQLTx`))",
							Args: []ir.FilterExpr{
								{
									Line: 282,
									Op:   ir.FilterOrOp,
									Src:  "m[\"db\"].Type.Implements(`pkg.SQLDb`) || m[\"db\"].Type.Implements(`pkg.SQLStmt`)",
									Args: []ir.FilterExpr{
										{
											Line:  282,
											Op:    ir.FilterVarTypeImplementsOp,
											Src:   "m[\"db\"].Type.Implements(`pkg.SQLDb`)",
											Value: "db",
											Args:  []ir.FilterExpr{{Line: 282, Op: ir.FilterStringOp, Src: "`pkg.SQLDb`", Value: "pkg.SQLDb"}},
										},
										{
											Line:  282,
											Op:    ir.FilterVarTypeImplementsOp,
											Src:   "m[\"db\"].Type.Implements(`pkg.SQLStmt`)",
											Value: "db",
											Args:  []ir.FilterExpr{{Line: 282, Op: ir.FilterStringOp, Src: "`pkg.SQLStmt`", Value: "pkg.SQLStmt"}},
										},
									},
								},
								{
									Line:  282,
									Op:    ir.FilterVarTypeImplementsOp,
									Src:   "m[\"db\"].Type.Implements(`pkg.SQLTx`)",
									Value: "db",
									Args:  []ir.FilterExpr{{Line: 282, Op: ir.FilterStringOp, Src: "`pkg.SQLTx`", Value: "pkg.SQLTx"}},
								},
							},
						},
					},
				},
				LocationVar: "db",
			}},
		},
		{
			Line:        291,
			Name:        "regexpCompileInLoop",
			MatcherName: "m",
			DocTags:     []string{"performance"},
			DocSummary:  "Detects regular expression compilation in loop",
			DocBefore:   "for { if regexp.MatchString(\"\\d\", \"123\") { /*...*/ } }",
			DocAfter:    "dig := regexp.MustCompile(\"\\d\"); for { if dig.MatchString(\"123\") { /*...*/ } }",
			Rules: []ir.Rule{{
				Line: 292,
				SyntaxPatterns: []ir.PatternString{
					{Line: 293, Value: "for $*_; $*_; $*_ { $*_; $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 294, Value: "for { $*_; $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 295, Value: "for $_, $_ := range $_ { $*_; $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 296, Value: "for $_, $_ = range $_ { $*_; $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 297, Value: "for $_ := range $_ { $*_; $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 298, Value: "for $_ = range $_ { $*_; $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 299, Value: "for range $_ { $*_; $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 301, Value: "for $*_; $*_; $*_ { $*_; $*_ := regexp.$method($s, $*args); $*_ }"},
					{Line: 302, Value: "for { $*_; $*_ := regexp.$method($s, $*args); $*_ }"},
					{Line: 303, Value: "for $_, $_ := range $_ { $*_; $*_ := regexp.$method($s, $*args); $*_ }"},
					{Line: 304, Value: "for $_, $_ = range $_ { $*_; $*_ := regexp.$method($s, $*args); $*_ }"},
					{Line: 305, Value: "for $_ := range $_ { $*_; $*_ := regexp.$method($s, $*args); $*_ }"},
					{Line: 306, Value: "for $_ = range $_ { $*_; $*_ := regexp.$method($s, $*args); $*_ }"},
					{Line: 307, Value: "for range $_ { $*_; $*_ := regexp.$method($s, $*args); $*_ }"},
					{Line: 309, Value: "for $*_; $*_; $*_ { $*_; var $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 310, Value: "for { $*_; var $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 311, Value: "for $_, $_ := range $_ { $*_; var $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 312, Value: "for $_, $_ = range $_ { $*_; var $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 313, Value: "for $_ := range $_ { $*_; var $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 314, Value: "for $_ = range $_ { $*_; var $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 315, Value: "for range $_ { $*_; var $*_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 317, Value: "for $*_; $*_; $*_ { $*_; var $*_ $_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 318, Value: "for { $*_; var $*_ $_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 319, Value: "for $_, $_ := range $_ { $*_; var $*_ $_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 320, Value: "for $_, $_ = range $_ { $*_; var $*_ $_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 321, Value: "for $_ := range $_ { $*_; var $*_ $_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 322, Value: "for $_ = range $_ { $*_; var $*_ $_ = regexp.$method($s, $*args); $*_ }"},
					{Line: 323, Value: "for range $_ { $*_; var $*_ $_ = regexp.$method($s, $*args); $*_ }"},
				},
				ReportTemplate: "don't compile regex in the loop, move it outside of the loop",
				WhereExpr: ir.FilterExpr{
					Line: 326,
					Op:   ir.FilterAndOp,
					Src:  "m[\"s\"].Const && m[\"method\"].Text.Matches(`Compile|MustCompilePOSIX|CompilePOSIX|Match|MatchString|MatchReader|MustCompile`)",
					Args: []ir.FilterExpr{
						{
							Line:  326,
							Op:    ir.FilterVarConstOp,
							Src:   "m[\"s\"].Const",
							Value: "s",
						},
						{
							Line:  326,
							Op:    ir.FilterVarTextMatchesOp,
							Src:   "m[\"method\"].Text.Matches(`Compile|MustCompilePOSIX|CompilePOSIX|Match|MatchString|MatchReader|MustCompile`)",
							Value: "method",
							Args:  []ir.FilterExpr{{Line: 326, Op: ir.FilterStringOp, Src: "`Compile|MustCompilePOSIX|CompilePOSIX|Match|MatchString|MatchReader|MustCompile`", Value: "Compile|MustCompilePOSIX|CompilePOSIX|Match|MatchString|MatchReader|MustCompile"}},
						},
					},
				},
				LocationVar: "s",
			}},
		},
		{
			Line:        334,
			Name:        "unclosedResource",
			MatcherName: "m",
			DocTags:     []string{"diagnostic"},
			DocSummary:  "Detects unreleased resources",
			DocBefore:   "s, _ := os.Open(\"foo.txt\"); s.Read(body); return body",
			DocAfter:    "s, _ := os.Open(\"foo.txt\"); defer s.Close(); s.Read(body); return body",
			Rules: []ir.Rule{{
				Line: 343,
				SyntaxPatterns: []ir.PatternString{
					{Line: 343, Value: "$res, $err := $open($*_); $*body"},
					{Line: 344, Value: "$res, $err = $open($*_); $*body"},
					{Line: 345, Value: "var $res, $err = $open($*_); $*body"},
				},
				ReportTemplate: "$res.Close() should be deferred right after the $open error check",
				WhereExpr: ir.FilterExpr{
					Line: 348,
					Op:   ir.FilterAndOp,
					Src:  "m[\"res\"].Type.Implements(`io.Closer`) &&\n\t!m[\"res\"].Object.IsGlobal() &&\n\tm[\"err\"].Type.Implements(`error`) &&\n\t!m[\"body\"].Contains(`$res.Close()`) &&\n\t!varEscapeFunction(m[\"body\"])",
					Args: []ir.FilterExpr{
						{
							Line: 348,
							Op:   ir.FilterAndOp,
							Src:  "m[\"res\"].Type.Implements(`io.Closer`) &&\n\t!m[\"res\"].Object.IsGlobal() &&\n\tm[\"err\"].Type.Implements(`error`) &&\n\t!m[\"body\"].Contains(`$res.Close()`)",
							Args: []ir.FilterExpr{
								{
									Line: 348,
									Op:   ir.FilterAndOp,
									Src:  "m[\"res\"].Type.Implements(`io.Closer`) &&\n\t!m[\"res\"].Object.IsGlobal() &&\n\tm[\"err\"].Type.Implements(`error`)",
									Args: []ir.FilterExpr{
										{
											Line: 348,
											Op:   ir.FilterAndOp,
											Src:  "m[\"res\"].Type.Implements(`io.Closer`) &&\n\t!m[\"res\"].Object.IsGlobal()",
											Args: []ir.FilterExpr{
												{
													Line:  348,
													Op:    ir.FilterVarTypeImplementsOp,
													Src:   "m[\"res\"].Type.Implements(`io.Closer`)",
													Value: "res",
													Args:  []ir.FilterExpr{{Line: 348, Op: ir.FilterStringOp, Src: "`io.Closer`", Value: "io.Closer"}},
												},
												{
													Line: 349,
													Op:   ir.FilterNotOp,
													Src:  "!m[\"res\"].Object.IsGlobal()",
													Args: []ir.FilterExpr{{
														Line:  349,
														Op:    ir.FilterVarObjectIsGlobalOp,
														Src:   "m[\"res\"].Object.IsGlobal()",
														Value: "res",
													}},
												},
											},
										},
										{
											Line:  350,
											Op:    ir.FilterVarTypeImplementsOp,
											Src:   "m[\"err\"].Type.Implements(`error`)",
											Value: "err",
											Args:  []ir.FilterExpr{{Line: 350, Op: ir.FilterStringOp, Src: "`error`", Value: "error"}},
										},
									},
								},
								{
									Line: 351,
									Op:   ir.FilterNotOp,
									Src:  "!m[\"body\"].Contains(`$res.Close()`)",
									Args: []ir.FilterExpr{{
										Line:  351,
										Op:    ir.FilterVarContainsOp,
										Src:   "m[\"body\"].Contains(`$res.Close()`)",
										Value: "body",
										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$res.Close()"}},
									}},
								},
							},
						},
						{
							Line: 352,
							Op:   ir.FilterNotOp,
							Src:  "!varEscapeFunction(m[\"body\"])",
							Args: []ir.FilterExpr{{
								Line: 352,
								Op:   ir.FilterOrOp,
								Src:  "varEscapeFunction(m[\"body\"])",
								Args: []ir.FilterExpr{
									{
										Line: 352,
										Op:   ir.FilterOrOp,
										Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $res`) ||\n\n\tm[\"body\"].Contains(`return $*_, $res, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $res`) ||\n\n\tm[\"body\"].Contains(`$_[$res] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $res;`) ||\n\n\tm[\"body\"].Contains(`$_ := $res;`) ||\n\n\tm[\"body\"].Contains(`var $_ = $res;`)",
										Args: []ir.FilterExpr{
											{
												Line: 352,
												Op:   ir.FilterOrOp,
												Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $res`) ||\n\n\tm[\"body\"].Contains(`return $*_, $res, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $res`) ||\n\n\tm[\"body\"].Contains(`$_[$res] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $res;`) ||\n\n\tm[\"body\"].Contains(`$_ := $res;`)",
												Args: []ir.FilterExpr{
													{
														Line: 352,
														Op:   ir.FilterOrOp,
														Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $res`) ||\n\n\tm[\"body\"].Contains(`return $*_, $res, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $res`) ||\n\n\tm[\"body\"].Contains(`$_[$res] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $res;`)",
														Args: []ir.FilterExpr{
															{
																Line: 352,
																Op:   ir.FilterOrOp,
																Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $res`) ||\n\n\tm[\"body\"].Contains(`return $*_, $res, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $res`) ||\n\n\tm[\"body\"].Contains(`$_[$res] = $_`)",
																Args: []ir.FilterExpr{
																	{
																		Line: 352,
																		Op:   ir.FilterOrOp,
																		Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $res`) ||\n\n\tm[\"body\"].Contains(`return $*_, $res, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $res`)",
																		Args: []ir.FilterExpr{
																			{
																				Line: 352,
																				Op:   ir.FilterOrOp,
																				Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $res`) ||\n\n\tm[\"body\"].Contains(`return $*_, $res, $*_`)",
																				Args: []ir.FilterExpr{
																					{
																						Line: 352,
																						Op:   ir.FilterOrOp,
																						Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $res`)",
																						Args: []ir.FilterExpr{
																							{
																								Line: 352,
																								Op:   ir.FilterOrOp,
																								Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`)",
																								Args: []ir.FilterExpr{
																									{
																										Line: 352,
																										Op:   ir.FilterOrOp,
																										Src:  "m[\"body\"].Contains(`$_($*_, $res, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $res, $*_}`)",
																										Args: []ir.FilterExpr{
																											{
																												Line:  352,
																												Op:    ir.FilterVarContainsOp,
																												Src:   "m[\"body\"].Contains(`$_($*_, $res, $*_)`)",
																												Value: "body",
																												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_($*_, $res, $*_)"}},
																											},
																											{
																												Line:  352,
																												Op:    ir.FilterVarContainsOp,
																												Src:   "m[\"body\"].Contains(`$_{$*_, $res, $*_}`)",
																												Value: "body",
																												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_{$*_, $res, $*_}"}},
																											},
																										},
																									},
																									{
																										Line:  352,
																										Op:    ir.FilterVarContainsOp,
																										Src:   "m[\"body\"].Contains(`$_{$*_, $_: $res, $*_}`)",
																										Value: "body",
																										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_{$*_, $_: $res, $*_}"}},
																									},
																								},
																							},
																							{
																								Line:  352,
																								Op:    ir.FilterVarContainsOp,
																								Src:   "m[\"body\"].Contains(`$_ <- $res`)",
																								Value: "body",
																								Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ <- $res"}},
																							},
																						},
																					},
																					{
																						Line:  352,
																						Op:    ir.FilterVarContainsOp,
																						Src:   "m[\"body\"].Contains(`return $*_, $res, $*_`)",
																						Value: "body",
																						Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "return $*_, $res, $*_"}},
																					},
																				},
																			},
																			{
																				Line:  352,
																				Op:    ir.FilterVarContainsOp,
																				Src:   "m[\"body\"].Contains(`$_[$_] = $res`)",
																				Value: "body",
																				Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_[$_] = $res"}},
																			},
																		},
																	},
																	{
																		Line:  352,
																		Op:    ir.FilterVarContainsOp,
																		Src:   "m[\"body\"].Contains(`$_[$res] = $_`)",
																		Value: "body",
																		Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_[$res] = $_"}},
																	},
																},
															},
															{
																Line:  352,
																Op:    ir.FilterVarContainsOp,
																Src:   "m[\"body\"].Contains(`$_ = $res;`)",
																Value: "body",
																Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ = $res;"}},
															},
														},
													},
													{
														Line:  352,
														Op:    ir.FilterVarContainsOp,
														Src:   "m[\"body\"].Contains(`$_ := $res;`)",
														Value: "body",
														Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ := $res;"}},
													},
												},
											},
											{
												Line:  352,
												Op:    ir.FilterVarContainsOp,
												Src:   "m[\"body\"].Contains(`var $_ = $res;`)",
												Value: "body",
												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "var $_ = $res;"}},
											},
										},
									},
									{
										Line:  352,
										Op:    ir.FilterVarContainsOp,
										Src:   "m[\"body\"].Contains(`var $_ $_ = $res;`)",
										Value: "body",
										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "var $_ $_ = $res;"}},
									},
								},
							}},
						},
					},
				},
				LocationVar: "res",
			}},
		},
		{
			Line:        362,
			Name:        "unstoppedTimer",
			MatcherName: "m",
			DocTags:     []string{"performance"},
			DocSummary:  "Detects unreleased timer",
			DocBefore:   "timer := time.NewTimer(time.Second); select { case <-timer.C: return nil; default: return nil }",
			DocAfter:    "timer := time.NewTimer(time.Second); defer timer.Stop(); select { case <-timer.C: return nil; default: return nil }",
			Rules: []ir.Rule{{
				Line: 371,
				SyntaxPatterns: []ir.PatternString{
					{Line: 371, Value: "$x := time.NewTimer($_); $*body"},
					{Line: 372, Value: "$x = time.NewTimer($_); $*body"},
					{Line: 373, Value: "var $x = time.NewTimer($_); $*body"},
					{Line: 374, Value: "var $x $_ = time.NewTimer($_); $*body"},
				},
				ReportTemplate: "unstopped timer",
				WhereExpr: ir.FilterExpr{
					Line: 375,
					Op:   ir.FilterAndOp,
					Src:  "!m[\"x\"].Object.IsGlobal() && !m[\"body\"].Contains(`$x.Stop()`) && !varEscapeFunction(m[\"body\"])",
					Args: []ir.FilterExpr{
						{
							Line: 375,
							Op:   ir.FilterAndOp,
							Src:  "!m[\"x\"].Object.IsGlobal() && !m[\"body\"].Contains(`$x.Stop()`)",
							Args: []ir.FilterExpr{
								{
									Line: 375,
									Op:   ir.FilterNotOp,
									Src:  "!m[\"x\"].Object.IsGlobal()",
									Args: []ir.FilterExpr{{
										Line:  375,
										Op:    ir.FilterVarObjectIsGlobalOp,
										Src:   "m[\"x\"].Object.IsGlobal()",
										Value: "x",
									}},
								},
								{
									Line: 375,
									Op:   ir.FilterNotOp,
									Src:  "!m[\"body\"].Contains(`$x.Stop()`)",
									Args: []ir.FilterExpr{{
										Line:  375,
										Op:    ir.FilterVarContainsOp,
										Src:   "m[\"body\"].Contains(`$x.Stop()`)",
										Value: "body",
										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$x.Stop()"}},
									}},
								},
							},
						},
						{
							Line: 375,
							Op:   ir.FilterNotOp,
							Src:  "!varEscapeFunction(m[\"body\"])",
							Args: []ir.FilterExpr{{
								Line: 375,
								Op:   ir.FilterOrOp,
								Src:  "varEscapeFunction(m[\"body\"])",
								Args: []ir.FilterExpr{
									{
										Line: 375,
										Op:   ir.FilterOrOp,
										Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $x;`) ||\n\n\tm[\"body\"].Contains(`$_ := $x;`) ||\n\n\tm[\"body\"].Contains(`var $_ = $x;`)",
										Args: []ir.FilterExpr{
											{
												Line: 375,
												Op:   ir.FilterOrOp,
												Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $x;`) ||\n\n\tm[\"body\"].Contains(`$_ := $x;`)",
												Args: []ir.FilterExpr{
													{
														Line: 375,
														Op:   ir.FilterOrOp,
														Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $x;`)",
														Args: []ir.FilterExpr{
															{
																Line: 375,
																Op:   ir.FilterOrOp,
																Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`)",
																Args: []ir.FilterExpr{
																	{
																		Line: 375,
																		Op:   ir.FilterOrOp,
																		Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`)",
																		Args: []ir.FilterExpr{
																			{
																				Line: 375,
																				Op:   ir.FilterOrOp,
																				Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`)",
																				Args: []ir.FilterExpr{
																					{
																						Line: 375,
																						Op:   ir.FilterOrOp,
																						Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`)",
																						Args: []ir.FilterExpr{
																							{
																								Line: 375,
																								Op:   ir.FilterOrOp,
																								Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`)",
																								Args: []ir.FilterExpr{
																									{
																										Line: 375,
																										Op:   ir.FilterOrOp,
																										Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`)",
																										Args: []ir.FilterExpr{
																											{
																												Line:  375,
																												Op:    ir.FilterVarContainsOp,
																												Src:   "m[\"body\"].Contains(`$_($*_, $x, $*_)`)",
																												Value: "body",
																												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_($*_, $x, $*_)"}},
																											},
																											{
																												Line:  375,
																												Op:    ir.FilterVarContainsOp,
																												Src:   "m[\"body\"].Contains(`$_{$*_, $x, $*_}`)",
																												Value: "body",
																												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_{$*_, $x, $*_}"}},
																											},
																										},
																									},
																									{
																										Line:  375,
																										Op:    ir.FilterVarContainsOp,
																										Src:   "m[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`)",
																										Value: "body",
																										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_{$*_, $_: $x, $*_}"}},
																									},
																								},
																							},
																							{
																								Line:  375,
																								Op:    ir.FilterVarContainsOp,
																								Src:   "m[\"body\"].Contains(`$_ <- $x`)",
																								Value: "body",
																								Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ <- $x"}},
																							},
																						},
																					},
																					{
																						Line:  375,
																						Op:    ir.FilterVarContainsOp,
																						Src:   "m[\"body\"].Contains(`return $*_, $x, $*_`)",
																						Value: "body",
																						Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "return $*_, $x, $*_"}},
																					},
																				},
																			},
																			{
																				Line:  375,
																				Op:    ir.FilterVarContainsOp,
																				Src:   "m[\"body\"].Contains(`$_[$_] = $x`)",
																				Value: "body",
																				Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_[$_] = $x"}},
																			},
																		},
																	},
																	{
																		Line:  375,
																		Op:    ir.FilterVarContainsOp,
																		Src:   "m[\"body\"].Contains(`$_[$x] = $_`)",
																		Value: "body",
																		Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_[$x] = $_"}},
																	},
																},
															},
															{
																Line:  375,
																Op:    ir.FilterVarContainsOp,
																Src:   "m[\"body\"].Contains(`$_ = $x;`)",
																Value: "body",
																Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ = $x;"}},
															},
														},
													},
													{
														Line:  375,
														Op:    ir.FilterVarContainsOp,
														Src:   "m[\"body\"].Contains(`$_ := $x;`)",
														Value: "body",
														Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ := $x;"}},
													},
												},
											},
											{
												Line:  375,
												Op:    ir.FilterVarContainsOp,
												Src:   "m[\"body\"].Contains(`var $_ = $x;`)",
												Value: "body",
												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "var $_ = $x;"}},
											},
										},
									},
									{
										Line:  375,
										Op:    ir.FilterVarContainsOp,
										Src:   "m[\"body\"].Contains(`var $_ $_ = $x;`)",
										Value: "body",
										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "var $_ $_ = $x;"}},
									},
								},
							}},
						},
					},
				},
				LocationVar: "x",
			}},
		},
		{
			Line:        384,
			Name:        "unstoppedTicker",
			MatcherName: "m",
			DocTags:     []string{"performance"},
			DocSummary:  "Detects unreleased ticker",
			DocBefore:   "ticker := time.NewTicker(time.Second); select { case <-ticker.C: return nil; default: return nil }",
			DocAfter:    "ticker := time.NewTicker(time.Second); defer ticker.Stop(); select { case <-ticker.C: return nil; default: return nil }",
			Rules: []ir.Rule{{
				Line: 393,
				SyntaxPatterns: []ir.PatternString{
					{Line: 393, Value: "$x := time.NewTicker($_); $*body"},
					{Line: 394, Value: "$x = time.NewTicker($_); $*body"},
					{Line: 395, Value: "var $x = time.NewTicker($_); $*body"},
					{Line: 396, Value: "var $x $_ = time.NewTicker($_); $*body"},
				},
				ReportTemplate: "unstopped ticker",
				WhereExpr: ir.FilterExpr{
					Line: 397,
					Op:   ir.FilterAndOp,
					Src:  "!m[\"x\"].Object.IsGlobal() && !m[\"body\"].Contains(`$x.Stop()`) && !varEscapeFunction(m[\"body\"])",
					Args: []ir.FilterExpr{
						{
							Line: 397,
							Op:   ir.FilterAndOp,
							Src:  "!m[\"x\"].Object.IsGlobal() && !m[\"body\"].Contains(`$x.Stop()`)",
							Args: []ir.FilterExpr{
								{
									Line: 397,
									Op:   ir.FilterNotOp,
									Src:  "!m[\"x\"].Object.IsGlobal()",
									Args: []ir.FilterExpr{{
										Line:  397,
										Op:    ir.FilterVarObjectIsGlobalOp,
										Src:   "m[\"x\"].Object.IsGlobal()",
										Value: "x",
									}},
								},
								{
									Line: 397,
									Op:   ir.FilterNotOp,
									Src:  "!m[\"body\"].Contains(`$x.Stop()`)",
									Args: []ir.FilterExpr{{
										Line:  397,
										Op:    ir.FilterVarContainsOp,
										Src:   "m[\"body\"].Contains(`$x.Stop()`)",
										Value: "body",
										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$x.Stop()"}},
									}},
								},
							},
						},
						{
							Line: 397,
							Op:   ir.FilterNotOp,
							Src:  "!varEscapeFunction(m[\"body\"])",
							Args: []ir.FilterExpr{{
								Line: 397,
								Op:   ir.FilterOrOp,
								Src:  "varEscapeFunction(m[\"body\"])",
								Args: []ir.FilterExpr{
									{
										Line: 397,
										Op:   ir.FilterOrOp,
										Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $x;`) ||\n\n\tm[\"body\"].Contains(`$_ := $x;`) ||\n\n\tm[\"body\"].Contains(`var $_ = $x;`)",
										Args: []ir.FilterExpr{
											{
												Line: 397,
												Op:   ir.FilterOrOp,
												Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $x;`) ||\n\n\tm[\"body\"].Contains(`$_ := $x;`)",
												Args: []ir.FilterExpr{
													{
														Line: 397,
														Op:   ir.FilterOrOp,
														Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`) ||\n\n\tm[\"body\"].Contains(`$_ = $x;`)",
														Args: []ir.FilterExpr{
															{
																Line: 397,
																Op:   ir.FilterOrOp,
																Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`) ||\n\n\tm[\"body\"].Contains(`$_[$x] = $_`)",
																Args: []ir.FilterExpr{
																	{
																		Line: 397,
																		Op:   ir.FilterOrOp,
																		Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`) ||\n\n\tm[\"body\"].Contains(`$_[$_] = $x`)",
																		Args: []ir.FilterExpr{
																			{
																				Line: 397,
																				Op:   ir.FilterOrOp,
																				Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`) ||\n\n\tm[\"body\"].Contains(`return $*_, $x, $*_`)",
																				Args: []ir.FilterExpr{
																					{
																						Line: 397,
																						Op:   ir.FilterOrOp,
																						Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_ <- $x`)",
																						Args: []ir.FilterExpr{
																							{
																								Line: 397,
																								Op:   ir.FilterOrOp,
																								Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`)",
																								Args: []ir.FilterExpr{
																									{
																										Line: 397,
																										Op:   ir.FilterOrOp,
																										Src:  "m[\"body\"].Contains(`$_($*_, $x, $*_)`) ||\n\n\tm[\"body\"].Contains(`$_{$*_, $x, $*_}`)",
																										Args: []ir.FilterExpr{
																											{
																												Line:  397,
																												Op:    ir.FilterVarContainsOp,
																												Src:   "m[\"body\"].Contains(`$_($*_, $x, $*_)`)",
																												Value: "body",
																												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_($*_, $x, $*_)"}},
																											},
																											{
																												Line:  397,
																												Op:    ir.FilterVarContainsOp,
																												Src:   "m[\"body\"].Contains(`$_{$*_, $x, $*_}`)",
																												Value: "body",
																												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_{$*_, $x, $*_}"}},
																											},
																										},
																									},
																									{
																										Line:  397,
																										Op:    ir.FilterVarContainsOp,
																										Src:   "m[\"body\"].Contains(`$_{$*_, $_: $x, $*_}`)",
																										Value: "body",
																										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_{$*_, $_: $x, $*_}"}},
																									},
																								},
																							},
																							{
																								Line:  397,
																								Op:    ir.FilterVarContainsOp,
																								Src:   "m[\"body\"].Contains(`$_ <- $x`)",
																								Value: "body",
																								Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ <- $x"}},
																							},
																						},
																					},
																					{
																						Line:  397,
																						Op:    ir.FilterVarContainsOp,
																						Src:   "m[\"body\"].Contains(`return $*_, $x, $*_`)",
																						Value: "body",
																						Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "return $*_, $x, $*_"}},
																					},
																				},
																			},
																			{
																				Line:  397,
																				Op:    ir.FilterVarContainsOp,
																				Src:   "m[\"body\"].Contains(`$_[$_] = $x`)",
																				Value: "body",
																				Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_[$_] = $x"}},
																			},
																		},
																	},
																	{
																		Line:  397,
																		Op:    ir.FilterVarContainsOp,
																		Src:   "m[\"body\"].Contains(`$_[$x] = $_`)",
																		Value: "body",
																		Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_[$x] = $_"}},
																	},
																},
															},
															{
																Line:  397,
																Op:    ir.FilterVarContainsOp,
																Src:   "m[\"body\"].Contains(`$_ = $x;`)",
																Value: "body",
																Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ = $x;"}},
															},
														},
													},
													{
														Line:  397,
														Op:    ir.FilterVarContainsOp,
														Src:   "m[\"body\"].Contains(`$_ := $x;`)",
														Value: "body",
														Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$_ := $x;"}},
													},
												},
											},
											{
												Line:  397,
												Op:    ir.FilterVarContainsOp,
												Src:   "m[\"body\"].Contains(`var $_ = $x;`)",
												Value: "body",
												Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "var $_ = $x;"}},
											},
										},
									},
									{
										Line:  397,
										Op:    ir.FilterVarContainsOp,
										Src:   "m[\"body\"].Contains(`var $_ $_ = $x;`)",
										Value: "body",
										Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "var $_ $_ = $x;"}},
									},
								},
							}},
						},
					},
				},
				LocationVar: "x",
			}},
		},
		{
			Line:        406,
			Name:        "simplifyErrorCheck",
			MatcherName: "m",
			DocTags:     []string{"style"},
			DocSummary:  "Detects expressions that can be rewritten in one 'if' form",
			DocBefore:   "err := myFunc(); if err != nil { println(err) }",
			DocAfter:    "if err := myFunc(); err != nil { println(err) }",
			Rules: []ir.Rule{
				{
					Line:            407,
					SyntaxPatterns:  []ir.PatternString{{Line: 407, Value: "$err := $f($*args); if $err != nil { $*body }"}},
					ReportTemplate:  "error check can be simplified in one line",
					SuggestTemplate: "if $err := $f($args); $err != nil { $body }",
					WhereExpr: ir.FilterExpr{
						Line: 408,
						Op:   ir.FilterAndOp,
						Src:  "m[\"err\"].Type.Implements(\"error\") &&\n\tm[\"f\"].Text.Matches(\"(?s)^.{0,40}$\") && m[\"args\"].Text.Matches(\"(?s)^.{0,40}$\")",
						Args: []ir.FilterExpr{
							{
								Line: 408,
								Op:   ir.FilterAndOp,
								Src:  "m[\"err\"].Type.Implements(\"error\") &&\n\tm[\"f\"].Text.Matches(\"(?s)^.{0,40}$\")",
								Args: []ir.FilterExpr{
									{
										Line:  408,
										Op:    ir.FilterVarTypeImplementsOp,
										Src:   "m[\"err\"].Type.Implements(\"error\")",
										Value: "err",
										Args:  []ir.FilterExpr{{Line: 408, Op: ir.FilterStringOp, Src: "\"error\"", Value: "error"}},
									},
									{
										Line:  409,
										Op:    ir.FilterVarTextMatchesOp,
										Src:   "m[\"f\"].Text.Matches(\"(?s)^.{0,40}$\")",
										Value: "f",
										Args:  []ir.FilterExpr{{Line: 409, Op: ir.FilterStringOp, Src: "\"(?s)^.{0,40}$\"", Value: "(?s)^.{0,40}$"}},
									},
								},
							},
							{
								Line:  409,
								Op:    ir.FilterVarTextMatchesOp,
								Src:   "m[\"args\"].Text.Matches(\"(?s)^.{0,40}$\")",
								Value: "args",
								Args:  []ir.FilterExpr{{Line: 409, Op: ir.FilterStringOp, Src: "\"(?s)^.{0,40}$\"", Value: "(?s)^.{0,40}$"}},
							},
						},
					},
				},
				{
					Line:            413,
					SyntaxPatterns:  []ir.PatternString{{Line: 413, Value: "$err = $f($*args); if $err != nil { $*body }"}},
					ReportTemplate:  "error check can be simplified in one line",
					SuggestTemplate: "if $err = $f($args); $err != nil { $body }",
					WhereExpr: ir.FilterExpr{
						Line: 414,
						Op:   ir.FilterAndOp,
						Src:  "m[\"err\"].Type.Implements(\"error\") &&\n\tm[\"f\"].Text.Matches(\"(?s)^.{0,40}$\") && m[\"args\"].Text.Matches(\"(?s)^.{0,40}$\")",
						Args: []ir.FilterExpr{
							{
								Line: 414,
								Op:   ir.FilterAndOp,
								Src:  "m[\"err\"].Type.Implements(\"error\") &&\n\tm[\"f\"].Text.Matches(\"(?s)^.{0,40}$\")",
								Args: []ir.FilterExpr{
									{
										Line:  414,
										Op:    ir.FilterVarTypeImplementsOp,
										Src:   "m[\"err\"].Type.Implements(\"error\")",
										Value: "err",
										Args:  []ir.FilterExpr{{Line: 414, Op: ir.FilterStringOp, Src: "\"error\"", Value: "error"}},
									},
									{
										Line:  415,
										Op:    ir.FilterVarTextMatchesOp,
										Src:   "m[\"f\"].Text.Matches(\"(?s)^.{0,40}$\")",
										Value: "f",
										Args:  []ir.FilterExpr{{Line: 415, Op: ir.FilterStringOp, Src: "\"(?s)^.{0,40}$\"", Value: "(?s)^.{0,40}$"}},
									},
								},
							},
							{
								Line:  415,
								Op:    ir.FilterVarTextMatchesOp,
								Src:   "m[\"args\"].Text.Matches(\"(?s)^.{0,40}$\")",
								Value: "args",
								Args:  []ir.FilterExpr{{Line: 415, Op: ir.FilterStringOp, Src: "\"(?s)^.{0,40}$\"", Value: "(?s)^.{0,40}$"}},
							},
						},
					},
				},
				{
					Line:            419,
					SyntaxPatterns:  []ir.PatternString{{Line: 419, Value: "var $err = $f($*args); if $err != nil { $*body }"}},
					ReportTemplate:  "error check can be simplified in one line",
					SuggestTemplate: "if $err := $f($args); $err != nil { $body }",
					WhereExpr: ir.FilterExpr{
						Line: 420,
						Op:   ir.FilterAndOp,
						Src:  "m[\"err\"].Type.Implements(\"error\") &&\n\tm[\"f\"].Text.Matches(\"(?s)^.{0,40}$\") && m[\"args\"].Text.Matches(\"(?s)^.{0,40}$\")",
						Args: []ir.FilterExpr{
							{
								Line: 420,
								Op:   ir.FilterAndOp,
								Src:  "m[\"err\"].Type.Implements(\"error\") &&\n\tm[\"f\"].Text.Matches(\"(?s)^.{0,40}$\")",
								Args: []ir.FilterExpr{
									{
										Line:  420,
										Op:    ir.FilterVarTypeImplementsOp,
										Src:   "m[\"err\"].Type.Implements(\"error\")",
										Value: "err",
										Args:  []ir.FilterExpr{{Line: 420, Op: ir.FilterStringOp, Src: "\"error\"", Value: "error"}},
									},
									{
										Line:  421,
										Op:    ir.FilterVarTextMatchesOp,
										Src:   "m[\"f\"].Text.Matches(\"(?s)^.{0,40}$\")",
										Value: "f",
										Args:  []ir.FilterExpr{{Line: 421, Op: ir.FilterStringOp, Src: "\"(?s)^.{0,40}$\"", Value: "(?s)^.{0,40}$"}},
									},
								},
							},
							{
								Line:  421,
								Op:    ir.FilterVarTextMatchesOp,
								Src:   "m[\"args\"].Text.Matches(\"(?s)^.{0,40}$\")",
								Value: "args",
								Args:  []ir.FilterExpr{{Line: 421, Op: ir.FilterStringOp, Src: "\"(?s)^.{0,40}$\"", Value: "(?s)^.{0,40}$"}},
							},
						},
					},
				},
			},
		},
		{
			Line:        428,
			Name:        "syncPoolNonPtr",
			MatcherName: "m",
			DocTags:     []string{"performance"},
			DocSummary:  "Non-pointer values in sync.Pool involve extra allocation",
			Rules: []ir.Rule{{
				Line:           435,
				SyntaxPatterns: []ir.PatternString{{Line: 435, Value: "$x.Put($y)"}},
				ReportTemplate: "non-pointer values in sync.Pool involve extra allocation",
				WhereExpr: ir.FilterExpr{
					Line: 436,
					Op:   ir.FilterAndOp,
					Src:  "m[\"x\"].Type.Is(\"sync.Pool\") && !isPointer(m[\"y\"])",
					Args: []ir.FilterExpr{
						{
							Line:  436,
							Op:    ir.FilterVarTypeIsOp,
							Src:   "m[\"x\"].Type.Is(\"sync.Pool\")",
							Value: "x",
							Args:  []ir.FilterExpr{{Line: 436, Op: ir.FilterStringOp, Src: "\"sync.Pool\"", Value: "sync.Pool"}},
						},
						{
							Line: 436,
							Op:   ir.FilterNotOp,
							Src:  "!isPointer(m[\"y\"])",
							Args: []ir.FilterExpr{{
								Line: 436,
								Op:   ir.FilterOrOp,
								Src:  "isPointer(m[\"y\"])",
								Args: []ir.FilterExpr{
									{
										Line: 436,
										Op:   ir.FilterOrOp,
										Src:  "m[\"y\"].Type.Underlying().Is(\"*$_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"chan $_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"map[$_]$_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"interface{$*_}\") ||\n\n\tm[\"y\"].Type.Underlying().Is(`func($*_) $*_`)",
										Args: []ir.FilterExpr{
											{
												Line: 436,
												Op:   ir.FilterOrOp,
												Src:  "m[\"y\"].Type.Underlying().Is(\"*$_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"chan $_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"map[$_]$_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"interface{$*_}\")",
												Args: []ir.FilterExpr{
													{
														Line: 436,
														Op:   ir.FilterOrOp,
														Src:  "m[\"y\"].Type.Underlying().Is(\"*$_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"chan $_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"map[$_]$_\")",
														Args: []ir.FilterExpr{
															{
																Line: 436,
																Op:   ir.FilterOrOp,
																Src:  "m[\"y\"].Type.Underlying().Is(\"*$_\") ||\n\n\tm[\"y\"].Type.Underlying().Is(\"chan $_\")",
																Args: []ir.FilterExpr{
																	{
																		Line:  436,
																		Op:    ir.FilterVarTypeUnderlyingIsOp,
																		Src:   "m[\"y\"].Type.Underlying().Is(\"*$_\")",
																		Value: "y",
																		Args:  []ir.FilterExpr{{Line: 430, Op: ir.FilterStringOp, Src: "\"*$_\"", Value: "*$_"}},
																	},
																	{
																		Line:  436,
																		Op:    ir.FilterVarTypeUnderlyingIsOp,
																		Src:   "m[\"y\"].Type.Underlying().Is(\"chan $_\")",
																		Value: "y",
																		Args:  []ir.FilterExpr{{Line: 430, Op: ir.FilterStringOp, Src: "\"chan $_\"", Value: "chan $_"}},
																	},
																},
															},
															{
																Line:  436,
																Op:    ir.FilterVarTypeUnderlyingIsOp,
																Src:   "m[\"y\"].Type.Underlying().Is(\"map[$_]$_\")",
																Value: "y",
																Args:  []ir.FilterExpr{{Line: 431, Op: ir.FilterStringOp, Src: "\"map[$_]$_\"", Value: "map[$_]$_"}},
															},
														},
													},
													{
														Line:  436,
														Op:    ir.FilterVarTypeUnderlyingIsOp,
														Src:   "m[\"y\"].Type.Underlying().Is(\"interface{$*_}\")",
														Value: "y",
														Args:  []ir.FilterExpr{{Line: 431, Op: ir.FilterStringOp, Src: "\"interface{$*_}\"", Value: "interface{$*_}"}},
													},
												},
											},
											{
												Line:  436,
												Op:    ir.FilterVarTypeUnderlyingIsOp,
												Src:   "m[\"y\"].Type.Underlying().Is(`func($*_) $*_`)",
												Value: "y",
												Args:  []ir.FilterExpr{{Line: 432, Op: ir.FilterStringOp, Src: "`func($*_) $*_`", Value: "func($*_) $*_"}},
											},
										},
									},
									{
										Line:  436,
										Op:    ir.FilterVarTypeUnderlyingIsOp,
										Src:   "m[\"y\"].Type.Underlying().Is(`unsafe.Pointer`)",
										Value: "y",
										Args:  []ir.FilterExpr{{Line: 432, Op: ir.FilterStringOp, Src: "`unsafe.Pointer`", Value: "unsafe.Pointer"}},
									},
								},
							}},
						},
					},
				},
				LocationVar: "y",
			}},
		},
		{
			Line:        443,
			Name:        "uselessLocalConst",
			MatcherName: "m",
			DocTags:     []string{"diagnostic"},
			DocSummary:  "Detects useless local constants",
			Rules: []ir.Rule{{
				Line: 444,
				SyntaxPatterns: []ir.PatternString{
					{Line: 444, Value: "const $x = $_; $*body"},
					{Line: 444, Value: "const $x $_ = $_; $*body"},
				},
				ReportTemplate: "useless local constant",
				WhereExpr: ir.FilterExpr{
					Line: 445,
					Op:   ir.FilterAndOp,
					Src:  "!m[\"x\"].Object.IsGlobal() && !m[\"body\"].Contains(`$x`)",
					Args: []ir.FilterExpr{
						{
							Line: 445,
							Op:   ir.FilterNotOp,
							Src:  "!m[\"x\"].Object.IsGlobal()",
							Args: []ir.FilterExpr{{
								Line:  445,
								Op:    ir.FilterVarObjectIsGlobalOp,
								Src:   "m[\"x\"].Object.IsGlobal()",
								Value: "x",
							}},
						},
						{
							Line: 445,
							Op:   ir.FilterNotOp,
							Src:  "!m[\"body\"].Contains(`$x`)",
							Args: []ir.FilterExpr{{
								Line:  445,
								Op:    ir.FilterVarContainsOp,
								Src:   "m[\"body\"].Contains(`$x`)",
								Value: "body",
								Args:  []ir.FilterExpr{{Line: 0, Op: ir.FilterStringOp, Src: "", Value: "$x"}},
							}},
						},
					},
				},
			}},
		},
	},
}

